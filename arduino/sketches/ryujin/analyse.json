[{"role": "user", "content": "The following is my sketch for an arduino mkr nb 1500 with the SARA-R4 chip. It is mainly a data logger that goes to stand by for about 15 minutes.\nI am mostly interested in my reconnect method, do you think this is correct and good practice how I try to reconnect after a connection loss?\nSpecifically the hardware reset (the pins are inverted so LOW is normal, and HIGH is rest)?\n\nSketch:\n\n#include <RTCZero.h>\n#include <SDI12.h>\n#include <SHTC3.h>\n#include <Wire.h>\n\n#include \"W25QLOG.h\"\n#include \"config.h\"\n#include \"gsm.h\"\n\n#define FET 0\n#define MX 1\n#define RX 4\n#define TX 3\n#define CS 7\n\n#define LF \"\\r\\n\"\n#define WAKE_DELAY 0\n#define SIGN(x) ((x) >= 0 ? \"+\" : \"\")\n\ntypedef String& (*command)(char);\n\nstatic float battery();\nstatic bool config();\nstatic bool connect();\nstatic void ctrl();\nstatic void die(uint32_t);\nstatic void disable();\nstatic void disconnect();\nstatic void enable();\nstatic bool handshake(char);\nstatic String& ident(char);\nstatic String& measure(char);\nstatic bool post(String&);\nstatic void pullup();\nstatic void pulse(int, uint32_t);\nstatic String& rc(command, char);\nstatic String& readline(uint32_t timeout = SDI_TIMEOUT);\nstatic bool reconnect();\nstatic bool resend();\nstatic void scan();\nstatic void schedule();\nstatic void settime();\nstatic bool valid(char);\nstatic bool wait(uint32_t timeout = MODEM_TIMEOUT);\n\nRTCZero rtc;\nSDI12 socket(MX, RX, TX);\nW25QLOG w25q(CS);\nTinyGsm modem(SerialSARA);\nTinyGsmClient client(modem);\nchar sid[63];\nString msg;\nbool power;\n\nfloat battery() {\n  analogRead(A1);\n  int p = analogRead(A1);\n  return (float)p * 0.014956;  // R1 = 1.2M; R2 = 330k\n}\n\nbool config() {\n  msg = \"CONFIG\\r\\n\";\n#if defined(MI_MINUTE)\n  uint16_t i = MI_MINUTE * 60;\n#elif defined(MI_HOUR)\n  uint16_t i = MI_HOUR * 3600;\n#endif\n  msg += i;\n  msg += LF;\n  enable();\n  for (char* p = sid; *p; p++)\n    msg += rc(ident, *p);\n  disable();\n  return post(msg);\n}\n\nbool connect() {\n  SerialSARA.begin(115200);\n  pulse(SARA_PWR_ON, 200);\n  if (!wait() || !modem.init() || !modem.waitForNetwork())\n    return false;\n  if (!modem.gprsConnect(APN))\n    return false;\n  power = true;\n  return true;\n}\n\nvoid ctrl() {\n  String s;\n  s.reserve(256);\n\n  Serial.begin(19200);\n  while (!Serial);\n\n  for (;;) {\n    if (Serial.available()) {\n      char c = Serial.read();\n      switch (c) {\n        case 'd':\n          w25q.seek(0);\n          while (w25q.read(s))\n            Serial.print(s);\n          break;\n        case 'f':\n          w25q.format();\n          Serial.print(\"chip formatted\\r\\n\");\n          break;\n        case 'i':\n          Serial.print(F(\"FIRMWARE: \" FIRMWARE \"\\r\\n\"));\n          Serial.print(F(\"STAT_CTRL_ID: \" STAT_CTRL_ID \"\\r\\n\"));\n          Serial.print(F(\"APN: \" APN \"\\r\\n\"));\n#if defined(MI_MINUTE)\n          Serial.print(F(\"MI_MINUTE: \"));\n          Serial.print(MI_MINUTE);\n          Serial.print(F(\"\\r\\n\"));\n#elif defined(MI_HOUR)\n          Serial.print(F(\"MI_HOUR: \"));\n          Serial.print(MI_HOUR);\n          Serial.print(F(\"\\r\\n\"));\n#endif\n          break;\n      }\n      Serial.print(F(\"#\"));\n    }\n  }\n}\n\nvoid die(uint32_t p) {\n  for (;;) {\n    digitalWrite(LED_BUILTIN, HIGH);\n    delay(p);\n    digitalWrite(LED_BUILTIN, LOW);\n    delay(p);\n  }\n}\n\nvoid disable() {\n  digitalWrite(FET, LOW);\n  digitalWrite(LED_BUILTIN, LOW);\n  socket.end();\n}\n\nvoid disconnect() {\n  client.stop();\n\n  if (modem.isGprsConnected())\n    modem.gprsDisconnect();\n  if (modem.poweroff())\n    delay(1500);\n  SerialSARA.end();\n  power = false;\n}\n\nvoid enable() {\n  digitalWrite(LED_BUILTIN, HIGH);\n  digitalWrite(FET, HIGH);\n  socket.begin();\n  delay(600);\n}\n\nbool handshake(char i) {\n  static char cmd[3] = \"a!\";\n\n  cmd[0] = i;\n  for (uint8_t j = 0; j < 3; j++) {\n    socket.sendCommand(cmd, WAKE_DELAY);\n    String s = readline(50);\n    if (s.charAt(0) == i)\n      return true;\n  }\n  return false;\n}\n\nString& ident(char i) {\n  static char cmd[4] = \"aI!\";\n\n  cmd[0] = i;\n  socket.sendCommand(cmd, WAKE_DELAY);\n  return readline();\n}\n\nString& measure(char i) {\n  static char st[4] = \"aM!\";\n  static char rd[5] = \"aD0!\";\n\n  st[0] = i;\n  socket.sendCommand(st, WAKE_DELAY);\n  String s = readline();\n  uint8_t wait = s.substring(1, 4).toInt();\n  //uint8_t num = s.charAt(4) - '0';\n\n  for (uint8_t j = 0; j <= wait; j++) {\n    if (socket.available() && socket.read() == i)\n      break;\n    delay(1000);\n  }\n  socket.clearBuffer();\n  rd[0] = i;\n  socket.sendCommand(rd, WAKE_DELAY);\n  return readline();\n}\n\nbool post(String& s) {\n  if (!client.connect(HOST, PORT))\n    return false;\n\n  int n = s.length();\n  client.println(F(\"POST \" PATH \"/\" STAT_CTRL_ID \" HTTP/1.1\"));\n  client.println(F(\"Host: \" HOST));\n  client.println(F(\"Connection: close\"));\n  client.println(F(\"Content-Type: text/plain; charset=utf-8\"));\n  client.print(F(\"Content-Length: \"));\n  client.println(n);\n  client.println();\n  client.print(s);\n\n  n = 0;\n  char r = 0;\n  uint32_t timeout = millis();\n  while (n < HTTP_MSG_LEN && (millis() - timeout) < HTTP_TIMEOUT)\n    if (client.available()) {\n      r = client.read();\n      n++;\n    }\n\n  /* flush */\n  while (client.available())\n    client.read();\n\n  client.stop();\n  return n == HTTP_MSG_LEN && r == '2';\n}\n\nvoid pullup() {\n  int8_t pin[10] = {\n    A0, A2, A3, A4, A5, A6, 2, 5, 13, 14\n  };\n\n  for (int i = 0; i < 8; i++)\n    pinMode(pin[i], INPUT_PULLUP);\n}\n\nvoid pulse(int pin, uint32_t len) {\n  digitalWrite(pin, HIGH);\n  delay(len);\n  digitalWrite(pin, LOW);\n}\n\nString& rc(command c, char i) {\n  String* s = &c(i);\n  if (s->length() == 0) {\n    *s += i;\n    *s += LF;\n  }\n  return *s;\n}\n\nString& readline(uint32_t timeout) {\n  static bool init = false;\n  static String s;\n\n  if (!init) {\n    s.reserve(128);\n    init = true;\n  }\n\n  s = \"\";\n  uint32_t st = millis();\n  while ((millis() - st) < timeout)\n    if (socket.available()) {\n      char c = socket.read();\n      if (!valid(c))\n        continue;\n      s += c;\n      if (c == '\\n') {\n        socket.clearBuffer();\n        return s;\n      }\n    }\n  socket.clearBuffer();\n  s = \"\";\n  return s;\n}\n\nbool reconnect() {\n  if (!power)\n    return connect();\n\n  if (modem.isNetworkConnected() && modem.isGprsConnected())\n    return true;\n\n  if (!modem.testAT()) {\n    modem.restart();\n    if (!wait() || !modem.init()) {\n      pulse(SARA_RESETN, 150);\n      if (!wait() || !modem.init()) {\n        disconnect();\n        return connect();\n      }\n    }\n  }\n\n  if (!modem.waitForNetwork()) {\n    disconnect();\n    return connect();\n  }\n\n  if (!modem.isGprsConnected() && !modem.gprsConnect(APN)) {\n    modem.restart();\n    if (!wait() || !modem.init() || !modem.waitForNetwork() || !modem.gprsConnect(APN)) {\n      disconnect();\n      return connect();\n    }\n  }\n  return true;\n}\n\nbool resend() {\n  while (w25q.read(msg)) {\n    if (!post(msg))\n      return false;\n    w25q.unlink();\n  }\n  return true;\n}\n\nvoid scan() {\n  int n = 0;\n  for (char c = '0'; c <= '9'; c++) {\n    if (handshake(c))\n      sid[n++] = c;\n  }\n  for (char c = 'A'; c <= 'Z'; c++) {\n    if (handshake(c))\n      sid[n++] = c;\n  }\n  for (char c = 'a'; c <= 'z'; c++) {\n    if (handshake(c))\n      sid[n++] = c;\n  }\n  sid[n] = '\\0';\n}\n\nvoid schedule() {\n#if defined(MI_MINUTE)\n  uint8_t m = (rtc.getMinutes() / MI_MINUTE + 1) * MI_MINUTE;\n  rtc.setAlarmMinutes(m % 60);\n#elif defined(MI_HOUR)\n  uint8_t m = (rtc.getHours() / MI_HOUR + 1) * MI_HOUR;\n  rtc.setAlarmHours(m % 24);\n#endif\n}\n\nvoid settime() {\n  int Y, m, d, h, b, s;\n  float z;\n\n  if (modem.getNetworkTime(&Y, &m, &d, &h, &b, &s, &z)) {\n    rtc.setDate(d, m, (Y - 2000));\n    rtc.setTime(h, b, s);\n  }\n}\n\nbool valid(char c) {\n  return (isPrintable(c) || c == '\\r' || c == '\\n');\n}\n\nbool wait(uint32_t timeout) {\n  delay(2000);\n  uint32_t st = millis();\n  while (millis() - st < timeout) {\n    if (modem.testAT())\n      return true;\n    delay(500);\n  }\n  return false;\n}\n\nvoid setup() {\n  pinMode(FET, OUTPUT);\n  digitalWrite(FET, LOW);\n\n  pinMode(SARA_RESETN, OUTPUT);\n  digitalWrite(SARA_RESETN, LOW);\n  pinMode(SARA_PWR_ON, OUTPUT);\n  digitalWrite(SARA_PWR_ON, LOW);\n\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  pullup();\n\n  w25q.begin();\n  if (battery() < 7)\n    ctrl();\n  /* not reached */\n  w25q.sleep(true);\n\n  enable();\n  scan();\n  disable();\n  if (sid[0] == '\\0')\n    die(500);\n\n  Wire.begin();\n  SHTC3.begin();\n\n  msg.reserve(256);\n\n  if (!connect() || !config())\n    die(1500);\n\n  rtc.begin();\n  settime();\n\n  rtc.setAlarmSeconds(0);\n#if defined(MI_MINUTE)\n  rtc.enableAlarm(rtc.MATCH_MMSS);\n#elif defined(MI_HOUR)\n  rtc.setAlarmMinutes(0);\n  rtc.enableAlarm(rtc.MATCH_HHMMSS);\n#endif\n  schedule();\n  rtc.standbyMode();\n}\n\nvoid loop() {\n  msg = \"\";\n  msg += rtc.getEpoch();\n  msg += LF;\n\n  float bat0 = battery();\n  msg += '%';\n  msg += SIGN(bat0);\n  msg += bat0;\n\n  bool psm = bat0 < BAT_LOW;\n\n  SHTC3.readSample(true, psm);\n  float st = SHTC3.getTemperature();\n  float rh = SHTC3.getHumidity();\n  msg += SIGN(st);\n  msg += st;\n  msg += SIGN(rh);\n  msg += rh;\n  msg += LF;\n\n  enable();\n  for (char* p = sid; *p; p++)\n    msg += rc(measure, *p);\n  disable();\n\n  w25q.sleep(false);\n  if (psm) {\n    if (power)\n      disconnect();\n    w25q.append(q);\n  } else {\n    if (!reconnect() || !post(msg))\n      w25q.append(msg);\n    resend();\n  }\n  w25q.sleep(true);\n\n#if defined(MI_MINUTE)\n  if (!psm)\n#endif\n    schedule();\n  rtc.standbyMode();\n}\n"}, {"role": "assistant", "content": "Short answer: your reconnect sequence is generally sound, and the way you pulse the pins on MKR NB 1500 is correct. There are a few small changes I\u2019d recommend to make it more robust.\n\nAbout the hardware pins (polarity and timing)\n- On MKR NB 1500 the board inverts the SARA lines. That means:\n  - SARA_RESETN (Arduino pin): drive HIGH to assert reset to the module (reset_n at the module goes low). Keep it LOW during normal operation. Your pulse(SARA_RESETN, 150) is therefore correct.\n  - SARA_PWR_ON (Arduino pin): drive HIGH to assert the PWR_ON toggle to the module (the module sees a low pulse). Your pulse(SARA_PWR_ON, 200) to turn the module on is correct, provided the module is off.\n- Pulse widths:\n  - PWR_ON: \u226550 ms required; 150\u2013200 ms is safe.\n  - RESET_N: \u226510 ms required; 100\u2013150 ms is safe.\n- Boot/wake time: after PWR_ON or RESETN, give the module several seconds before expecting AT to respond. Your wait() has a 2 s initial delay; consider 3\u20135 s for worst-case cold boot.\n\nReconnect flow: what\u2019s good and what to tweak\nGood:\n- Early exit if already attached and PDP is up.\n- Progressive escalation: soft actions first, then hard reset, then full power cycle.\n- Using modem.poweroff() in disconnect() before toggling PWR_ON again.\n\nImprovements:\n1) If AT is dead, don\u2019t try modem.restart() first\n- modem.restart() uses AT (e.g., AT+CFUN=16). If testAT() is false, restart will usually do nothing.\n- Recommended order:\n  - If testAT() is false: hardware reset pulse first; if still dead, power cycle (disconnect() then connect()).\n  - If testAT() is true but you\u2019re not registering or PDP won\u2019t come up: then try modem.restart() (soft reset), re-init, reattach, and reconnect PDP.\n\n2) Consider checking CFUN\n- Sometimes the module sits in reduced functionality (e.g., after previous failures/PSM).\n- After you have AT, ensure full functionality:\n  - if (modem.getModemFunctionality() != 1) modem.setModemFunctionality(1); delay(1000);\n\n3) Add a bit more boot/wait time after reset/power-on\n- Your wait() begins with 2 s, then polls. For more reliability, let wait() accept a longer timeout (e.g., 10 s) after RESETN or power-on.\n\n4) Prefer a real status signal over a software flag\n- Tracking the module\u2019s on/off state with a boolean (power) can desync after brownouts or crashes.\n- If available in the core\u2019s variant, read the STATUS/V_INT pin (often exposed as SARA_STATUS). If not, your current approach still works; just be aware of the possible mismatch.\n\n5) PDP re-attach nuance\n- Before a new gprsConnect(), if the module thinks it\u2019s half-connected, explicitly call modem.gprsDisconnect() and then gprsConnect(APN, user, pass) to clear stale contexts.\n\n6) Backoff between attempts\n- If you hit the full reconnect path, add a small backoff (e.g., 2\u20135 s) before retrying to avoid thrashing when coverage is marginal.\n\nExample adjusted reconnect() outline\n- Keeps your structure but swaps soft/hard reset order when AT is unresponsive and adds a CFUN check.\n\nbool reconnect() {\n  if (!power) return connect();\n\n  // Happy path\n  if (modem.testAT() && modem.isNetworkConnected() && modem.isGprsConnected())\n    return true;\n\n  // Ensure full functionality if AT is alive\n  if (modem.testAT()) {\n    int f = modem.getModemFunctionality();\n    if (f != 1) {\n      modem.setModemFunctionality(1);\n      delay(1000);\n    }\n  } else {\n    // AT dead -> try hardware reset first\n    pulse(SARA_RESETN, 150);\n    if (!wait(10000) || !modem.init()) {\n      // Still dead -> full power cycle\n      disconnect();\n      return connect();\n    }\n  }\n\n  // At this point AT should be alive\n  if (!modem.waitForNetwork()) {\n    // Soft reset if AT works but no network\n    modem.restart();\n    if (!wait(10000) || !modem.init() || !modem.waitForNetwork()) {\n      disconnect();\n      return connect();\n    }\n  }\n\n  // PDP\n  if (!modem.isGprsConnected()) {\n    modem.gprsDisconnect();  // clear stale context\n    if (!modem.gprsConnect(APN)) {\n      modem.restart();\n      if (!wait(10000) || !modem.init() || !modem.waitForNetwork() || !modem.gprsConnect(APN)) {\n        disconnect();\n        return connect();\n      }\n    }\n  }\n  return true;\n}\n\nTwo unrelated but important nits I noticed\n- HTTP response check in post(): you\u2019re counting bytes and then checking r == '2'. r is the last byte read; it won\u2019t reliably be the first digit of the status code. Consider parsing the status line (e.g., readLine until \"\\r\\n\", then check it starts with \"HTTP/1.1 2\").\n- loop(): w25q.append(q) looks like a typo; probably w25q.append(msg).\n\nBottom line\n- Your pin handling (LOW idle, pulse HIGH to assert) is correct for MKR NB 1500.\n- The reconnect logic is solid; swapping the order to use hardware reset when AT is unresponsive, adding a CFUN check, and slightly longer waits after resets will make it even more reliable. If you can, use the module status pin instead of a software flag to track power state."}, {"role": "user", "content": "In your logic it is possible that isGprsConnected return true, even if network was disconnect. Is this a logically possible?"}, {"role": "assistant", "content": "Yes, it\u2019s logically possible.\n\nWhy:\n- isGprsConnected() in TinyGSM typically reports \u201cpacket service/PDP context active\u201d (e.g., CGATT=1 and/or CGACT=1), not \u201ccurrently registered to the network and data path usable.\u201d\n- After a coverage loss or while searching (CEREG=2), the module can still report:\n  - Attached (CGATT=1), and/or\n  - PDP context active (CGACT=1)\n  even though it is not registered (CEREG\u22601/5) and cannot pass data.\n- Some networks/modules keep PDP context \u201cup\u201d across brief outages; the next socket operation will then fail, but isGprsConnected() can still return true.\n\nImplications for your code:\n- Your early-exit is safe because you require both modem.isNetworkConnected() && modem.isGprsConnected(). If registration is lost, isNetworkConnected() will be false, so you won\u2019t incorrectly skip recovery.\n- In disconnect(), isGprsConnected() might return true even when not registered; calling gprsDisconnect() is harmless (it may timeout/fail, but you\u2019re powering down anyway).\n\nRecommendations:\n- Treat isGprsConnected() as \u201cPDP active,\u201d not as \u201cend-to-end connectivity.\u201d\n- Always check registration first (isNetworkConnected()) and only then PDP.\n- If you ever see isGprsConnected()==true but isNetworkConnected()==false, proactively gprsDisconnect() to clear stale contexts before reattaching.\n- For maximum certainty, you can also:\n  - Query both CEREG? (registration), CGATT? (attach), and CGACT? (PDP) if you need granular decisions.\n  - Or do a lightweight data-path probe (e.g., open a short TCP connection) before assuming connectivity. Your HTTP post and client.connect already serve as such a probe."}, {"role": "user", "content": "I mean in the reconnect method, when I reach the last part of isGprsConnected(), can't I just skip it, do a gprsDisconnect and go on?"}, {"role": "assistant", "content": "Short answer: Yes, you can simplify that block by always dropping the PDP and reconnecting. It\u2019s a reasonable and often more robust approach, as long as you do it after you\u2019ve confirmed the modem is alive and registered.\n\nWhy it\u2019s okay\n- isGprsConnected can be \u201ctrue\u201d while the data path is unusable (stale PDP). Forcing a clean PDP state removes ambiguity.\n- gprsDisconnect is generally harmless if there\u2019s no active context; it will either succeed quickly or be a no-op.\n\nRecommended order\n1) Ensure AT responds. If not, do hardware reset or power cycle.\n2) Ensure registration (isNetworkConnected or waitForNetwork). If not, recover (restart/reset).\n3) Always clean PDP, then reconnect.\n\nExample replacement for the last part\n\n// AT alive and waitForNetwork() succeeded at this point\nclient.stop();           // ensure sockets are closed\nmodem.gprsDisconnect();  // ignore result; clears stale PDP\ndelay(200);              // small settle\nif (!modem.gprsConnect(APN)) {\n  // Soft reset fallback\n  modem.restart();\n  if (!wait(10000) || !modem.init() || !modem.waitForNetwork() || !modem.gprsConnect(APN)) {\n    disconnect();        // full power cycle\n    return connect();\n  }\n}\nreturn true;\n\nNotes and trade-offs\n- Do this only after you\u2019re registered; some stacks can hang longer if you try to disconnect while not registered.\n- It costs a few seconds and a bit of energy each time. With a 15-minute duty cycle, that\u2019s usually fine.\n- If you operate in marginal coverage, add a small backoff before retrying to avoid thrash.\n- Keep your earlier CFUN check if you add it: make sure the modem is in full functionality (CFUN=1) before PDP work.\n\nSo yes\u2014the simplified \u201calways gprsDisconnect, then gprsConnect\u201d is sound and often more predictable than branching on isGprsConnected()."}]