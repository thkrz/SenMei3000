[{"role": "user", "content": "Here is a sketch for a data logger based on the arduino mkr nb 1500. Do you have any strong criticism?\n\nSketch:\n\n#include <RTCZero.h>\n#include <SDI12.h>\n#include <SHTC3.h>\n#include <Wire.h>\n\n#include \"W25QLOG.h\"\n#include \"config.h\"\n#include \"gsm.h\"\n\n#define FET 0\n#define MX 1\n#define RX 4\n#define TX 3\n#define CS 7\n\n#define LF \"\\r\\n\"\n#define WAKE_DELAY 0\n#define SIGN(x) ((x) >= 0 ? '+' : '\\0')\n\ntypedef String& (*command)(char);\n\nstatic float battery();\nstatic bool config();\nstatic bool connect();\nstatic void ctrl();\nstatic void die(uint32_t);\nstatic void disable();\nstatic void disconnect();\nstatic void enable();\nstatic bool handshake(char);\nstatic String& ident(char);\nstatic String& measure(char);\nstatic bool ping();\nstatic bool post(String&);\nstatic void pullup();\nstatic void pulse(int, uint32_t);\nstatic String& rc(command, char);\nstatic String& readline(uint32_t timeout = SDI_TIMEOUT);\nstatic bool reconnect();\nstatic bool resend();\nstatic void scan();\nstatic void schedule();\nstatic void settime();\nstatic bool valid(char);\nstatic bool wait(uint32_t timeout = MODEM_TIMEOUT);\n\nRTCZero rtc;\nSDI12 socket(MX, RX, TX);\nW25QLOG w25q(CS);\nTinyGsm modem(SerialSARA);\nTinyGsmClient client(modem);\nchar sid[63];\nString q;\nbool power;\n\nfloat battery() {\n  analogRead(A1);\n  int p = analogRead(A1);\n  return (float)p * 0.014956;  // R1 = 1.2M; R2 = 330k\n}\n\nbool config() {\n  String s = \"CONFIG\\r\\n\";\n#if defined(MI_MINUTE)\n  uint16_t i = MI_MINUTE * 60;\n#elif defined(MI_HOUR)\n  uint16_t i = MI_HOUR * 3600;\n#endif\n  s += i;\n  s += LF;\n  enable();\n  for (char* p = sid; *p; p++)\n    s += rc(ident, *p);\n  disable();\n  return post(s);\n}\n\nbool connect() {\n  SerialSARA.begin(115200);\n  pulse(SARA_PWR_ON, 200);\n  if (!wait() || !modem.init() || !modem.waitForNetwork())\n    return false;\n  if (!modem.gprsConnect(APN))\n    return false;\n  power = true;\n  return true;\n}\n\nvoid ctrl() {\n  String s;\n  s.reserve(256);\n\n  Serial.begin(19200);\n  while (!Serial);\n\n  for (;;) {\n    if (Serial.available()) {\n      char c = Serial.read();\n      switch (c) {\n        case 'd':\n          w25q.seek(0);\n          while (w25q.read(s))\n            Serial.print(s);\n          break;\n        case 'f':\n          w25q.format();\n          Serial.print(\"chip formatted\\r\\n\");\n          break;\n        case 'i':\n          Serial.print(F(\"FIRMWARE: \" FIRMWARE \"\\r\\n\"));\n          Serial.print(F(\"STAT_CTRL_ID: \" STAT_CTRL_ID \"\\r\\n\"));\n          Serial.print(F(\"APN: \" APN \"\\r\\n\"));\n#if defined(MI_MINUTE)\n          Serial.print(F(\"MI_MINUTE: \"));\n          Serial.print(MI_MINUTE);\n          Serial.print(F(\"\\r\\n\"));\n#elif defined(MI_HOUR)\n          Serial.print(F(\"MI_HOUR: \"));\n          Serial.print(MI_HOUR);\n          Serial.print(F(\"\\r\\n\"));\n#endif\n          break;\n      }\n      Serial.print(F(\"#\"));\n    }\n  }\n}\n\nvoid die(uint32_t p) {\n  for (;;) {\n    digitalWrite(LED_BUILTIN, HIGH);\n    delay(p);\n    digitalWrite(LED_BUILTIN, LOW);\n    delay(p);\n  }\n}\n\nvoid disable() {\n  digitalWrite(FET, LOW);\n  digitalWrite(LED_BUILTIN, LOW);\n  socket.end();\n}\n\nvoid disconnect() {\n  client.stop();\n\n  if (modem.isGprsConnected())\n    modem.gprsDisconnect();\n  if (modem.poweroff())\n    delay(1500);\n  SerialSARA.end();\n  power = false;\n}\n\nvoid enable() {\n  digitalWrite(LED_BUILTIN, HIGH);\n  digitalWrite(FET, HIGH);\n  socket.begin();\n  delay(600);\n}\n\nbool handshake(char i) {\n  static char cmd[3] = \"a!\";\n\n  cmd[0] = i;\n  for (int j = 0; j < 3; j++) {\n    socket.sendCommand(cmd, WAKE_DELAY);\n    String s = readline(50);\n    if (s.charAt(0) == i)\n      return true;\n  }\n  return false;\n}\n\nString& ident(char i) {\n  static char cmd[4] = \"aI!\";\n\n  cmd[0] = i;\n  socket.sendCommand(cmd, WAKE_DELAY);\n  return readline();\n}\n\nString& measure(char i) {\n  static char st[4] = \"aM!\";\n  static char rd[5] = \"aD0!\";\n\n  st[0] = i;\n  socket.sendCommand(st, WAKE_DELAY);\n  String s = readline();\n  uint8_t wait = s.substring(1, 4).toInt();\n  //uint8_t num = s.charAt(4) - '0';\n\n  for (int j = 0; j <= wait; j++) {\n    if (socket.available() && socket.read() == i)\n      break;\n    delay(1000);\n  }\n  socket.clearBuffer();\n  rd[0] = i;\n  socket.sendCommand(rd, WAKE_DELAY);\n  return readline();\n}\n\nbool ping() {\n  TinyGsmClient probe(modem);\n  if (probe.connect(F(\"8.8.8.8\"), 53)) {\n    probe.stop();\n    return true;\n  }\n  return false;\n}\n\nbool post(String& s) {\n  if (!client.connect(HOST, PORT))\n    return false;\n\n  int n = s.length();\n  client.println(F(\"POST \" PATH \"/\" STAT_CTRL_ID \" HTTP/1.1\"));\n  client.println(F(\"Host: \" HOST));\n  client.println(F(\"Connection: close\"));\n  client.println(F(\"Content-Type: text/plain; charset=utf-8\"));\n  client.print(F(\"Content-Length: \"));\n  client.println(n);\n  client.println();\n  client.print(s);\n\n  n = 0;\n  char r = 0;\n  uint32_t timeout = millis();\n  while (n < HTTP_MSG_LEN && (millis() - timeout) < HTTP_TIMEOUT)\n    if (client.available()) {\n      r = client.read();\n      n++;\n    }\n\n  /* flush */\n  while (client.available())\n    client.read();\n\n  client.stop();\n  return n == HTTP_MSG_LEN && r == '2';\n}\n\nvoid pullup() {\n  int8_t pin[10] = {\n    A0, A2, A3, A4, A5, A6, 2, 5, 13, 14\n  };\n\n  for (int i = 0; i < 10; i++)\n    pinMode(pin[i], INPUT_PULLUP);\n}\n\nvoid pulse(int pin, uint32_t len) {\n  digitalWrite(pin, HIGH);\n  delay(len);\n  digitalWrite(pin, LOW);\n}\n\nString& rc(command c, char i) {\n  String* s = &c(i);\n  if (s->length() == 0) {\n    *s += i;\n    *s += LF;\n  }\n  return *s;\n}\n\nString& readline(uint32_t timeout) {\n  static String s;\n\n  s = \"\";\n  uint32_t st = millis();\n  while ((millis() - st) < timeout)\n    if (socket.available()) {\n      char c = socket.read();\n      if (!valid(c))\n        continue;\n      s += c;\n      if (c == '\\n') {\n        socket.clearBuffer();\n        return s;\n      }\n    }\n  socket.clearBuffer();\n  s = \"\";\n  return s;\n}\n\nbool reconnect() {\n  if (!power)\n    return connect();\n\n  if (modem.isNetworkConnected() && modem.isGprsConnected() && ping())\n    return true;\n\n  for (uint8_t j = 0; j < 3; j++) {\n    if (!modem.testAT()) {\n      pulse(SARA_RESETN, 150);\n      wait();\n      modem.init();\n    }\n    if (modem.waitForNetwork()) {\n      modem.gprsDisconnect();\n      if (modem.gprsConnect(APN) && ping())\n        return true;\n    }\n    modem.restart();\n  }\n  return false;\n}\n\nbool resend() {\n  static String s;\n\n  while (w25q.read(s)) {\n    if (!post(s))\n      return false;\n    w25q.unlink();\n  }\n  return true;\n}\n\nvoid scan() {\n  int n = 0;\n  for (char c = '0'; c <= '9'; c++) {\n    if (handshake(c))\n      sid[n++] = c;\n  }\n  for (char c = 'A'; c <= 'Z'; c++) {\n    if (handshake(c))\n      sid[n++] = c;\n  }\n  for (char c = 'a'; c <= 'z'; c++) {\n    if (handshake(c))\n      sid[n++] = c;\n  }\n  sid[n] = '\\0';\n}\n\nvoid schedule() {\n#if defined(MI_MINUTE)\n  uint8_t m = (rtc.getMinutes() / MI_MINUTE + 1) * MI_MINUTE;\n  rtc.setAlarmMinutes(m % 60);\n#elif defined(MI_HOUR)\n  uint8_t m = (rtc.getHours() / MI_HOUR + 1) * MI_HOUR;\n  rtc.setAlarmHours(m % 24);\n#endif\n}\n\nvoid settime() {\n  int Y, m, d, h, b, s;\n  float z;\n\n  if (modem.getNetworkTime(&Y, &m, &d, &h, &b, &s, &z)) {\n    rtc.setDate(d, m, (Y - 2000));\n    rtc.setTime(h, b, s);\n  }\n}\n\nbool valid(char c) {\n  return (isPrintable(c) || c == '\\r' || c == '\\n');\n}\n\nbool wait(uint32_t timeout) {\n  delay(2000);\n  uint32_t st = millis();\n  while (millis() - st < timeout) {\n    if (modem.testAT())\n      return true;\n    delay(500);\n  }\n  return false;\n}\n\nvoid setup() {\n  pinMode(FET, OUTPUT);\n  digitalWrite(FET, LOW);\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n  pinMode(SARA_RESETN, OUTPUT);\n  digitalWrite(SARA_RESETN, LOW);\n  pinMode(SARA_PWR_ON, OUTPUT);\n  digitalWrite(SARA_PWR_ON, LOW);\n\n  pullup();\n\n  w25q.begin();\n  if (battery() < 7)\n    ctrl();\n    /* not reached */\n  w25q.sleep(true);\n\n  enable();\n  scan();\n  disable();\n  if (sid[0] == '\\0')\n    die(500);\n\n  Wire.begin();\n  SHTC3.begin();\n\n  q.reserve(256);\n\n  if (!connect() || !config())\n    die(1500);\n\n  rtc.begin();\n  settime();\n\n  rtc.setAlarmSeconds(0);\n#if defined(MI_MINUTE)\n  rtc.enableAlarm(rtc.MATCH_MMSS);\n#elif defined(MI_HOUR)\n  rtc.setAlarmMinutes(0);\n  rtc.enableAlarm(rtc.MATCH_HHMMSS);\n#endif\n  schedule();\n  rtc.standbyMode();\n}\n\nvoid loop() {\n  q = \"\";\n  q += rtc.getEpoch();\n  q += LF;\n\n  float bat0 = battery();\n  q += '%';\n  q += SIGN(bat0);\n  q += bat0;\n\n  bool psm = bat0 < BAT_LOW;\n\n  SHTC3.readSample(true, psm);\n  float st = SHTC3.getTemperature();\n  float rh = SHTC3.getHumidity();\n  q += SIGN(st);\n  q += st;\n  q += SIGN(rh);\n  q += rh;\n  q += LF;\n\n  enable();\n  for (char* p = sid; *p; p++)\n    q += rc(measure, *p);\n  disable();\n\n  w25q.sleep(false);\n  if (psm) {\n    if (power)\n      disconnect();\n    w25q.append(q);\n  } else if (!reconnect() || !resend() || !post(q))\n    w25q.append(q);\n  w25q.sleep(true);\n\n#if defined(MI_MINUTE)\n  if (!psm)\n#endif\n    schedule();\n  rtc.standbyMode();\n}\n"}, {"role": "assistant", "content": "Below is a collection of the issues that jump out when the sketch is reviewed from the perspectives of robustness, portability, power consumption and general C++ hygiene.  Most of them are \u201ccan bite you in the field\u201d problems that should be fixed before you put hardware in a box and deploy it for months.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n1. Memory-management / \u201cString\u201d hell\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2022 The SAMD21 on the MKR NB 1500 has 32 kB of SRAM, but you are building and copying\n  several dynamic Arduino String objects (q, s, the static strings returned by ident/meas,\n  the HTTP header lines, etc.).  \n  \u2013 Repeated concatenations allocate/reallocate the heap \u2192 fragmentation +\n    run-time peaks you cannot predict.  \n  \u2013 On bad RSSI days when the modem produces a few kB of diagnostics you might\n    simply run out of RAM and crash.\n\n  Replace almost everything that uses String with either:\n    \u2022 print() / println() chains to a Stream-derived object (client, w25q, Serial\u2026), or\n    \u2022 fixed char buffers that you build with snprintf().\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n2. SIGN() macro inserts NULs\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n#define SIGN(x) ((x) >= 0 ? '+' : '\\0')\n\nWhen x < 0 you append ASCII 0 into q:\n\n    q += SIGN(st);\n\nso the payload contains embedded NUL characters.  \nHTTP bodies are length-counted, but the target PHP/Go/Python code that\nparses the payload will almost certainly treat \u2018\\0\u2019 as end-of-string.  \nReturn '-' instead, or just return an empty string:\n\n#define SIGN(x) ((x) >= 0 ? '+' : '\\0')   // bad\n#define SIGNCH(x) ((x) >= 0 ? '+' : '-') // if you really need a char\n#define SIGNSTR(x) ((x) >= 0 ? \"+\" : \"\") // if you need a string\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n3. Returning references to static String objects\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nident(), measure(), readline() all return String& that is backed by a single static\ninstance.  rc() stores a pointer to that object and then returns it to the caller.\nEvery subsequent call overwrites the same underlying buffer, so when you build\nq inside the for loop\n\n    q += rc(measure, *p);\n\nthe second sensor will overwrite what you just appended for sensor 0.\nYou were probably fooled because the program \u201cseems\u201d to work when you print\nimmediately after each call.  Change rc() to copy the value, or make the static\ninside ident/measure local to rc instead.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n4. Double analogRead() and scale factor\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nbattery() does:\n\n  analogRead(A1);\n  int p = analogRead(A1);\n\n\u2022 The discard-first-sample trick is fine, but SAMD21 default ADC is 12-bit, not the AVR\n  10-bit your magic factor (0.014956) assumes.  \n\u2022 Use the real reference voltage (VREF), divider ratio and ADC resolution in the\n  calculation:\n\n  const float AREF = 3.30;      // Vref you configured\n  const float R1   = 1.2e6;\n  const float R2   = 330e3;\n\n  float battery()\n  {\n      /* throw away 1st reading */ analogRead(A1);\n      uint16_t v = analogRead(A1);           // 0-4095\n      float vin = (float)v * AREF / 4095.0;  // volts at A1\n      return vin * (R1 + R2) / R2;           // battery volts\n  }\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n5. Macro-constructed F() strings\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  client.println(F(\"Host: \" HOST));\n\nF() works only with compile-time literals.  \nAfter macro concatenation the compiler still sees a literal, so this line compiles,\nbut GCC places the merged string in PROGMEM as one big literal\n(\u201cHost: your.server.com\u201d).  \nIf HOST ever becomes a run-time string you will chase very strange bugs.  \nEither pre-concatenate with the pre-processor\n\n  client.println(F(\"Host: \" HOST));\n\nor build the header at run-time and skip F().\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n6. rc() silently sweeps missing sensor answers under the carpet\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nIf a sensor does not reply, rc() inserts \u201c<address><CR><LF>\u201d.  \nOn the server side you have no way to distinguish \u201creal empty reading\u201d from\n\u201csensor missing\u201d.  Consider inserting a sentinel (\u201cNA\u201d) or moving the address to a\nfield name rather than re-using the data field itself.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n7. Crash-only \u201cdie()\u201d loop\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ndie() flashes the LED forever.  \nThat is acceptable during development but a poor idea in a system that should\nself-recover.  Instead\n\n  \u2022 print a reason code,\n  \u2022 de-energise peripherals,\n  \u2022 feed the watchdog so it reboots after a minute,\n  \u2022 or at least enter deep-sleep to save the battery.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n8. Standby/sleep vs watchdog\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nrtc.standbyMode() stops the CPU but not the GSM; if the modem is left powered\n(psm==false) it will draw \u227350 mA all the time.  \nMake sure you also drive SARA_PWR_ON low before sleeping or enable the modem\u2019s\nPSM/eDRX.  \nAdd a watchdog (WDT) that is reset every loop so that you reboot if the GSM stack\nlocks up (common with the SARA-R4/R5).\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n9. Pulse lengths and waiting for the modem\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThe power-on sequence for the SARA-R410 requires\n  \u2022 5 ms LOW,\n  \u2022 \u2265150 ms HIGH,\n  \u2022 then wait min \u2022 5 s before sending AT.\n\nYour 200 ms HIGH is fine, but you also call wait() after only 2 s.  \nIncrease the guard time to 5 s or use TinyGsm\u2019s waitForResponse().\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n10. Pin conflicts\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nMX = pin 1 (the hardware TX pin).  \nIf you ever enable Serial (USB CDC) with USB disconnected, the bootloader falls\nback to UART\u2010Serial on pins 0/1 and will fight with the SDI-12 transceiver.  \nPick a pin that is not tied to SERCOM/SPI/I\u00b2C.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n11. W25Q pull-ups before SPI.begin()\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npullup() sets pins 13 and 14 (SCK, MISO) to INPUT_PULLUP, then w25q.begin()\ndoes a SPI.begin() which re-configures them.  \nThat won\u2019t break anything, but wastes power and one extra milli-second at every\nboot.  Simply remove 13 and 14 from the pull-up list.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n12. Miscellaneous nits\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2022 reconnect(): you loop j<3, but inside you call modem.restart() which already\n  toggles the power pins; the SARA is quite sensitive to brown-out.  \n\u2022 measure(): you ignore the number-of-values character (spec says D0..D9).  \n  Ask for every block or honour that digit.  \n\u2022 Heart-beat LED remains HIGH for almost the whole \u201cenable()\u201d period.  If the\n  station is solar-powered the LED alone can drain \u22482 mA continuously.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nWhat to fix first?\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n1. Remove Arduino String everywhere.  \n2. Fix SIGN() / embedded NUL bug.  \n3. Correct the battery measurement maths.  \n4. Re-work rc()/static-String plumbing so that measurements are not overwritten.  \n5. Add WDT and a deterministic recovery path instead of die().  \n6. Verify the modem power-up timing and use TinyGsm functions rather than home-brew delays.  \n7. Tighten the error handling of SPI-flash and SHTC3 initialisation (abort if begin() fails).\n\nWith those items addressed the logger will be far more reliable in long-term field deployments."}, {"role": "user", "content": "modem.restart does not toggle the power pins, it sends an AT command. w25q does not call SPI.begin(). the adc of the mkr nb 1500 is in standard 10bit, but can do 8bit or 12 bit as well."}, {"role": "assistant", "content": "Thanks for the clarifications.  Here is an updated review that removes the parts that were based on wrong assumptions and keeps (or adds) the items that are still worth fixing.\n\n0. Corrections to my previous remarks  \n   \u2022 TinyGsm::restart() \u2013 you are right, on the SARA-R4 it is implemented as  \n     AT+CFUN=16 (soft reset).  It does not touch the PWR_ON or RESET_N pins.  \n   \u2022 Your W25QLOG library apparently expects the user to have done SPI.begin()\n     somewhere else; if that is indeed the case then the pull-up remark is moot.  \n   \u2022 The default analogRead() resolution on the MKR NB 1500 is 10 bit\n     (analogReadResolution(10)).  The scale factor you use is therefore correct.\n\nWith that out of the way, here is the cleaned-up \u201cmust / should / could\u201d list.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n1. KEEP \u201cget rid of Arduino String\u201d (strongly recommended)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nDynamic String concatenation is still the biggest single risk for an embedded\nlogger that must survive months of autonomous operation.\nUse fixed char buffers or write directly to the destination stream.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n2. Fix the SIGN macro (embedded NULs)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n#define SIGN(x) ((x) >= 0 ? '+' : '\\0')\n\nWhen x < 0 you append ASCII 0 to q, creating \u201cC-strings\u201d inside the payload.\nSwitch to \u201c'-'\u201d when negative or to an empty string.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n3. References to static String\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nident(), measure() and readline() expose the same static object each time.\nThe append in\n\n    q += rc(measure, *p);\n\nworks now (because q copies the chars immediately) but is fragile:\na future refactor that stores the reference instead of copying would break\nsilently.  Prefer returning a const char* or filling a caller-supplied buffer.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n4. Battery measurement (minor)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEven though 10-bit is the current default, explicitly set the resolution once\nin setup():\n\n    analogReadResolution(10);\n\nso the result does not silently change when somebody edits another sketch and\nforgets to set it back.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n5. die() power behaviour\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nInstead of an infinite LED-blink loop you can:\n\n    \u2022 turn off peripherals (disable(), disconnect()),\n    \u2022 write the reason code to flash,\n    \u2022 feed the watchdog once and then enter deep sleep.\nThis protects the battery and still allows you to diagnose the failure later.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n6. Modem timing\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nYou still call wait() after only 2 s.  \nThe SARA-R4 data-sheet recommends \u22655 s before the first AT after PWR_ON\u2191.\nIncrease the delay or poll the VINT pin (if wired).\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n7. rc() ambiguity on missing sensor replies\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThe current placeholder \u201c<addr><CR><LF>\u201d does not let the back-end distinguish\nbetween \u201csensor present, but sent an empty string\u201d and \u201cno reply at all\u201d.\nInsert a sentinel (e.g. \u201cNA\u201d) or encode the status elsewhere.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n8. measure(): honour the \u201cnumber of data fields\u201d digit\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAccording to the SDI-12 spec, the \u2018M\u2019 response contains the number of blocks\nthat will be available (D0 \u2026 D9).  Your code always requests D0 only.\nIf any sensor ever returns more than nine values you will silently drop them.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n9. Watchdog and GSM hangs\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nThe SARA family still freezes occasionally.  \nEnable the SAMD21 watchdog (WDT) and kick it once per main loop; if the modem\nor TinyGsm blocks, the MCU will reboot and start clean.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n10. Pin 1 conflict when USB is detached\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nIf the bootloader falls back to UART-Serial on 0/1 it will collide with the\nSDI-12 transceiver that you mapped to pin 1 (MX).  Consider selecting any other\nunused pin for MX.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n11. Cosmetic / maintainability\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2022 Use constexpr or const uint16_t instead of #define for numeric constants; the\n  compiler can type-check them.  \n\u2022 Wrap all compile-time configuration (APN, HOST, PORT, etc.) in a single struct\n  so it is obvious which parameters belong to which build.  \n\u2022 document the power budget of enable()/disable() and the expected time-on-air.\n\nIf you address 1, 2, 5, 6 and add a watchdog the logger should be robust enough\nfor long-term deployments; the remaining items will make maintenance easier but\nare not show-stoppers."}, {"role": "user", "content": "can you give an example for number 9? The watchdog?"}, {"role": "assistant", "content": "Below is a short, self-contained example that illustrates how you can add a watchdog to an\nMKR NB 1500 (SAMD21) sketch without pulling-in big dependencies.  \nThe same technique can be dropped into your data-logger:  \n\n1.  enable the WDT when the CPU starts a \u201cwork phase\u201d,  \n2.  kick it (\u201creset it\u201d) from every long-running loop,  \n3.  disable it (or pause it) before you put the MCU in standby-sleep so that it does **not**\n    expire while the processor is deliberately off.  \n\nThe code uses the device registers directly; no external library is required.\n\n--------------------------------------------------------------------\nMinimal helper\n--------------------------------------------------------------------\n```cpp\n/* ---------- watchdog_samd21.h ---------- */\n#pragma once\n#include <sam.h>\n\nnamespace WDTutil {\n\n  // ------------- time-out table -------------\n  // period code | cycles | 1.024 kHz clock \u2248   |\n  //     0       |   8    |   7.8 ms            |\n  //     1       |  16    |  15.6 ms            |\n  // ...\n  //     9       | 8192   |   8   s  (largest)  |\n  constexpr uint8_t PERIOD_8S = 9;   // pick the largest slot\n\n  inline void enable(uint8_t periodCode = PERIOD_8S, bool runInStandby = false)\n  {\n    // Feed once in case the WDT was already running\n    WDT->CLEAR.reg = WDT_CLEAR_KEY;\n    while (WDT->STATUS.bit.SYNCBUSY);\n\n    // Generic clock: connect OSCULP32K (32.768 kHz /32 = 1.024 kHz)\n    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(WDT_GCLK_ID) |\n                        GCLK_CLKCTRL_CLKEN           |\n                        GCLK_CLKCTRL_GEN_GCLK1;      // GCLK1 = OSCULP32K/32\n    while (GCLK->STATUS.bit.SYNCBUSY);\n\n    // Configure timeout and behaviour in standby\n    WDT->CONFIG.reg = periodCode;                    // see table above\n    WDT->CTRL.reg   = (runInStandby ? WDT_CTRL_WEN : 0) | WDT_CTRL_ENABLE;\n    while (WDT->STATUS.bit.SYNCBUSY);\n\n    // First clear starts the counter\n    WDT->CLEAR.reg = WDT_CLEAR_KEY;\n  }\n\n  inline void reset()\n  {\n    WDT->CLEAR.reg = WDT_CLEAR_KEY;            // \u201ckick the dog\u201d\n    while (WDT->STATUS.bit.SYNCBUSY);\n  }\n\n  inline void disable()\n  {\n    /* Disable the peripheral completely        */\n    /* (must write CTRL.ENABLE=0 while CLEAR=key) */\n    WDT->CLEAR.reg = WDT_CLEAR_KEY;\n    while (WDT->STATUS.bit.SYNCBUSY);\n    WDT->CTRL.reg  = 0;\n    while (WDT->STATUS.bit.SYNCBUSY);\n  }\n\n  inline bool lastResetWasWatchdog()\n  {\n    return (RSTC->RCAUSE.reg & RSTC_RCAUSE_WDT);\n  }\n}\n```\n\n--------------------------------------------------------------------\nHow you would use it in your logger\n--------------------------------------------------------------------\n```cpp\n#include \"watchdog_samd21.h\"\n\n/* ----------------------------------------------------------------\n   setup()\n------------------------------------------------------------------*/\nvoid setup()\n{\n  /*  optional: discover whether we rebooted because of the WDT  */\n  if (WDTutil::lastResetWasWatchdog()) {\n      Serial.begin(115200);\n      while (!Serial);\n      Serial.println(F(\"Resumed after watchdog reset!\"));\n  }\n\n  /* ... your existing setup code ... */\n}\n\n/* ----------------------------------------------------------------\n   loop()\n------------------------------------------------------------------*/\nvoid loop()\n{\n  /* ---------------- \u201cwork phase\u201d ---------------- */\n  WDTutil::enable();             // start 8-second watchdog\n\n  q = \"\";                        // build payload, take ADC, etc.\n\n  /* Long loops: remember to kick the dog           */\n  enable();\n  for (char *p = sid; *p; ++p) {\n      q += rc(measure, *p);\n      WDTutil::reset();          // we could be inside a 2-3-second exchange\n  }\n  disable();\n\n  /* More potentially long blocks */\n  if (!reconnect() || !resend() || !post(q)) {\n      w25q.append(q);\n  }\n  WDTutil::reset();              // AT / TCP may have taken time\n\n  /* ------------- finished with active work ------------- */\n  WDTutil::disable();            // stop WDT before going to deep sleep\n\n  /* programme next RTC alarm and sleep exactly like today */\n  schedule();\n  rtc.standbyMode();             // CPU off, GSM possibly off as well\n}\n```\n\nImportant details\n\n\u2022  PERIOD 9 (= 8 s) is the largest interval the SAMD21 offers; if some of your modem\n   exchanges last longer, call `WDTutil::reset()` inside those loops (as in the example).\n\n\u2022  We *disable* the watchdog before `rtc.standbyMode()` because the low-power\n   sleep will last minutes or hours and would otherwise guarantee a reset.\n\n\u2022  If you would rather keep the dog running during sleep (to recover from a\n   frozen RTC, for instance), pass `runInStandby = true` to `enable()` **and**\n   choose a period that exceeds your worst-case sleep time; this inevitably means\n   you lose sub-minute granularity.\n\n\u2022  The helper also provides `lastResetWasWatchdog()` so you can log or treat a WDT\n   reboot differently from a POR/BOD reset.\n\n\u2022  For ultra-compact code you can replace `watchdog_samd21.h` with a\n   three-line `#include <Adafruit_SleepyDog.h>` solution; the principle\n   (enable \u2192 reset in long loops \u2192 disable before standby) is exactly the same."}]